<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Serial Printer (Image, Text & Last.fm)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }

        h1 {
            color: #111;
        }

        button,
        input,
        textarea {
            font-size: 16px;
            padding: 10px 15px;
            margin-right: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            vertical-align: middle;
            box-sizing: border-box;
            /* Consistent sizing */
        }

        button {
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }

        button:disabled {
            background-color: #ccc;
        }

        input[type="range"] {
            width: 200px;
            background-color: transparent;
            -webkit-appearance: none;
            margin: 0;
            padding: 0;
            border: none;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: #ddd;
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #007bff;
            margin-top: -6px;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            margin-bottom: 10px;
        }

        #controls,
        #lastFmControls {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9e9e9;
            border-radius: 5px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        #lastFmControls {
            flex-direction: column;
            align-items: stretch;
        }

        #controls label {
            font-weight: bold;
            margin-right: 5px;
        }

        #status {
            font-size: 18px;
            font-weight: bold;
            margin-top: 20px;
        }

        #previewContainer {
            margin-top: 20px;
            border: 1px dashed #ccc;
            padding: 10px;
            text-align: center;
            background-color: #fff;
        }

        #previewCanvas {
            border: 1px solid #333;
            background-color: #fff;
            max-width: 100%;
            height: auto;
        }

        #log {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            height: 200px;
            overflow-y: scroll;
            font-family: "Courier New", Courier, monospace;
            white-space: pre-wrap;
        }

        .tab-bar {
            border-bottom: 2px solid #ccc;
            margin-top: 20px;
        }

        .tab-link {
            font-size: 18px;
            padding: 10px 20px;
            border: none;
            background-color: transparent;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            color: #555;
        }

        .tab-link.active {
            border-bottom-color: #007bff;
            font-weight: bold;
            color: #000;
        }

        .tab-content {
            display: none;
            padding-top: 20px;
        }

        .tab-content.active {
            display: block;
        }

        #textInputArea {
            width: 100%;
            height: 150px;
            font-size: 16px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #textModeControls {
            text-align: right;
        }

        #lastFmStatus {
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
    </style>
</head>

<body>
    <h1>"Raw" Browser Printer (Image, Text & Last.fm)</h1>
    <p>Connect, select a mode, and print.</p>

    <button id="connectButton">Connect to Printer</button>

    <div id="status">STATUS: DISCONNECTED</div>

    <!-- --- Tab Navigation --- -->
    <div class="tab-bar">
        <button class="tab-link active" id="tabImage">Print Image</button>
        <button class="tab-link" id="tabText">Print Text</button>
        <button class="tab-link" id="tabLastFm">Print Last.fm</button>
    </div>

    <!-- --- Image Mode Content --- -->
    <div id="imageMode" class="tab-content active">
        <div id="controls">
            <input type="file" id="fileInput" accept=".bmp,.png,.jpg,.jpeg,.gif" disabled>
            <label for="contrastSlider">Contrast Threshold:</label>
            <input type="range" id="contrastSlider" min="0" max="255" value="128" disabled>
            <span id="contrastValue">128</span>
            <button id="printImageButton" disabled>Print Image</button>
        </div>

        <div id="previewContainer">
            <p>Image Preview (384px width)</p>
            <canvas id="previewCanvas"></canvas>
        </div>
    </div>

    <!-- --- Text Mode Content --- -->
    <div id="textMode" class="tab-content">
        <p>Enter text, then generate an image to print.</p>
        <textarea id="textInputArea" placeholder="Hello world..." disabled></textarea>
        <div id="textModeControls">
            <button id="generateTextButton" disabled>Generate Image from Text</button>
        </div>
    </div>

    <!-- --- Last.fm Mode Content --- -->
    <div id="lastFmMode" class="tab-content">
        <p>Enter your Last.fm username and API key. It will poll every 30 seconds and automatically print new songs
            you're listening to.</p>
        <div id="lastFmControls">
            <input type="password" id="lastFmApiKey" placeholder="Last.fm API Key (Get from last.fm/api/account/create)"
                disabled>
            <input type="text" id="lastFmUsername" placeholder="Last.fm Username" disabled>
            <div>
                <button id="startPollingButton" disabled>Start Polling</button>
                <button id="stopPollingButton" disabled>Stop Polling</button>
            </div>
        </div>
        <div id="lastFmStatus">Connect printer to enable.</div>
    </div>

    <pre id="log">Awaiting connection...</pre>

    <script>
        // --- Get UI Elements ---
        const connectButton = document.getElementById('connectButton');
        const fileInput = document.getElementById('fileInput');
        const contrastSlider = document.getElementById('contrastSlider');
        const contrastValueSpan = document.getElementById('contrastValue');
        const printImageButton = document.getElementById('printImageButton');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');

        // --- Tab Elements ---
        const tabImage = document.getElementById('tabImage');
        const tabText = document.getElementById('tabText');
        const tabLastFm = document.getElementById('tabLastFm');
        const imageModeDiv = document.getElementById('imageMode');
        const textModeDiv = document.getElementById('textMode');
        const lastFmModeDiv = document.getElementById('lastFmMode');

        // --- Text Mode Elements ---
        const textInputArea = document.getElementById('textInputArea');
        const generateTextButton = document.getElementById('generateTextButton');

        // --- Last.fm Elements ---
        const lastFmApiKey = document.getElementById('lastFmApiKey');
        const lastFmUsername = document.getElementById('lastFmUsername');
        const startPollingButton = document.getElementById('startPollingButton');
        const stopPollingButton = document.getElementById('stopPollingButton');
        const lastFmStatus = document.getElementById('lastFmStatus');

        // --- Printer Constants ---
        const PRINTER_WIDTH_PX = 384;
        const SLICE_HEIGHT_PX = 8;
        const BAUD_RATE = 9600;

        // --- ESC/POS Command Constants (as Uint8Arrays) ---
        const INIT = new Uint8Array([0x1B, 0x40]); // Initialize Printer
        const FEED_ONE_LINE = new Uint8Array([0x0A]); // Simple Line Feed (LF)

        // --- Global State ---
        let port;
        let writer;
        let currentImage = null; // Stores the loaded image object for preview/print
        let pollingInterval = null;
        let lastPrintedTrack = "";

        /**
         * Logs a message to the on-screen console.
         */
        function log(message) {
            console.log(message);
            logDiv.textContent += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // --- Tab Switching Logic ---
        function openTab(tabId) {
            [tabImage, tabText, tabLastFm].forEach(tab => tab.classList.remove('active'));
            [imageModeDiv, textModeDiv, lastFmModeDiv].forEach(div => div.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');

            if (tabId === 'tabImage') imageModeDiv.classList.add('active');
            else if (tabId === 'tabText') textModeDiv.classList.add('active');
            else if (tabId === 'tabLastFm') lastFmModeDiv.classList.add('active');
        }
        tabImage.addEventListener('click', () => openTab('tabImage'));
        tabText.addEventListener('click', () => openTab('tabText'));
        tabLastFm.addEventListener('click', () => openTab('tabLastFm'));

        /**
         * Handles the "Connect" button click.
         */
        connectButton.addEventListener('click', async () => {
            try {
                log('Requesting serial port...');
                port = await navigator.serial.requestPort();
                log(`Opening port at ${BAUD_RATE} baud...`);
                await port.open({ baudRate: BAUD_RATE });
                writer = port.writable.getWriter();

                log('--- PRINTER CONNECTED ---');
                statusDiv.textContent = 'STATUS: CONNECTED (Light should stop blinking)';
                statusDiv.style.color = 'green';
                connectButton.disabled = true;

                // Enable controls
                fileInput.disabled = false;
                textInputArea.disabled = false;
                generateTextButton.disabled = false;
                lastFmApiKey.disabled = false;
                lastFmUsername.disabled = false;
                startPollingButton.disabled = false;
                lastFmStatus.textContent = 'Ready to poll.';

                port.addEventListener('close', () => {
                    log('--- PRINTER DISCONNECTED ---');
                    statusDiv.textContent = 'STATUS: DISCONNECTED';
                    statusDiv.style.color = 'red';
                    connectButton.disabled = false;

                    // Disable all controls
                    fileInput.disabled = true;
                    contrastSlider.disabled = true;
                    printImageButton.disabled = true;
                    textInputArea.disabled = true;
                    generateTextButton.disabled = true;

                    // Disable Last.fm
                    lastFmApiKey.disabled = true;
                    lastFmUsername.disabled = true;
                    startPollingButton.disabled = true;
                    stopPollingButton.disabled = true;
                    lastFmStatus.textContent = 'Connect printer to enable.';
                    if (pollingInterval) clearInterval(pollingInterval); // Stop polling on disconnect

                    if (writer) writer.releaseLock();
                });

            } catch (err) {
                log(`--- CONNECTION ERROR ---`);
                log(err.message);
            }
        });

        /**
         * Handles the file input.
         * Loads the image and displays a preview.
         */
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            log(`File selected: ${file.name}`);
            try {
                const imageUrl = URL.createObjectURL(file);
                currentImage = new Image();
                currentImage.onload = async () => {
                    log('Image loaded. Displaying preview...');
                    displayImageOnCanvas(currentImage, parseInt(contrastSlider.value));
                    URL.revokeObjectURL(imageUrl);
                    contrastSlider.disabled = false;
                    printImageButton.disabled = false;
                };
                currentImage.onerror = () => log('Error loading image.');
                currentImage.src = imageUrl;
            } catch (err) {
                log(`--- IMAGE PROCESSING ERROR ---`);
                log(err.message);
            }
        });

        /**
         * Updates the image preview on the canvas.
         * @param {Image} img The loaded HTML Image object.
         * @param {number} contrastThreshold The threshold for B&W conversion.
         */
        function displayImageOnCanvas(img, contrastThreshold) {
            if (!img) {
                previewCanvas.width = PRINTER_WIDTH_PX;
                previewCanvas.height = 50;
                previewCtx.fillStyle = '#FFFFFF';
                previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.fillStyle = '#AAAAAA';
                previewCtx.textAlign = 'center';
                previewCtx.fillText('No image loaded', PRINTER_WIDTH_PX / 2, 25);
                return;
            }

            const scaledHeight = Math.floor(img.height * (PRINTER_WIDTH_PX / img.width));
            previewCanvas.width = PRINTER_WIDTH_PX;
            previewCanvas.height = scaledHeight;
            previewCtx.drawImage(img, 0, 0, PRINTER_WIDTH_PX, scaledHeight);

            const imageData = previewCtx.getImageData(0, 0, PRINTER_WIDTH_PX, scaledHeight);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i + 1], b = data[i + 2];
                const average = (0.2126 * r + 0.7152 * g + 0.0722 * b);
                const bw = average < contrastThreshold ? 0 : 255;
                data[i] = bw; data[i + 1] = bw; data[i + 2] = bw;
            }
            previewCtx.putImageData(imageData, 0, 0);
        }

        /**
         * Event listener for the contrast slider. Updates the preview.
         */
        contrastSlider.addEventListener('input', () => {
            const threshold = parseInt(contrastSlider.value);
            contrastValueSpan.textContent = threshold;
            if (currentImage) {
                displayImageOnCanvas(currentImage, threshold);
            }
        });

        /**
         * REFACTORED: Event listener for the "Print Image" button.
         * This now just calls the reusable printImage function.
         */
        printImageButton.addEventListener('click', async () => {
            if (!currentImage) {
                log('No image loaded to print.');
                return;
            }
            if (!writer) {
                log('Printer not connected.');
                return;
            }

            log('--- Starting Image Print Job ---');
            printImageButton.disabled = true;
            fileInput.disabled = true;
            contrastSlider.disabled = true;

            try {
                const threshold = parseInt(contrastSlider.value);
                await printImage(currentImage, threshold, false); // Explicitly set skipFeed to false
                log('--- Print Job Finished ---');
            } catch (err) {
                log(`--- PRINT ERROR ---`);
                log(err.message);
            } finally {
                printImageButton.disabled = false;
                fileInput.disabled = false;
                contrastSlider.disabled = false;
            }
        });

        /**
         * REFACTORED: Generates an Image object from text.
         * @param {string} text The text to render.
         * @returns {Promise<Image>} A promise that resolves with the generated Image.
         */
        function generateImageFromText(text) {
            return new Promise((resolve, reject) => {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const canvasWidth = 384;
                    const fontSize = 20;
                    const lineHeight = 24;
                    const padding = 5;
                    ctx.font = `${fontSize}px sans-serif`;

                    // --- Text Wrapping Logic (Handles auto-wrap AND manual newlines) ---
                    const paragraphs = text.split('\n');
                    const lines = [];
                    for (const para of paragraphs) {
                        const words = para.split(' ');
                        let currentLine = '';
                        for (const word of words) {
                            const testLine = currentLine + word + ' ';
                            const metrics = ctx.measureText(testLine);
                            if (metrics.width > (canvasWidth - padding * 2) && currentLine !== '') {
                                lines.push(currentLine.trim());
                                currentLine = word + ' ';
                            } else {
                                currentLine = testLine;
                            }
                        }
                        lines.push(currentLine.trim());
                    }

                    const canvasHeight = (lines.length * lineHeight) + (padding * 2);
                    canvas.width = canvasWidth;
                    canvas.height = canvasHeight;

                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                    ctx.fillStyle = '#000000';
                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.textBaseline = 'top';

                    for (let i = 0; i < lines.length; i++) {
                        ctx.fillText(lines[i], padding, padding + (i * lineHeight));
                    }

                    const dataUrl = canvas.toDataURL();
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('Error converting canvas to image.'));
                    img.src = dataUrl;

                } catch (err) {
                    reject(err);
                }
            });
        }

        /**
         * REFACTORED: Event listener for "Generate Image from Text" button.
         * Now uses the reusable function and loads the result into the Image tab.
         */
        generateTextButton.addEventListener('click', async () => {
            const text = textInputArea.value;
            if (!text) {
                log('No text to generate.');
                return;
            }
            log('Generating image from text...');
            generateTextButton.disabled = true;
            try {
                // 1. Generate the image
                const img = await generateImageFromText(text);

                // 2. Load it into the Image Mode tab
                currentImage = img; // Set the global image
                displayImageOnCanvas(currentImage, parseInt(contrastSlider.value));

                // 3. Enable controls and switch tabs
                contrastSlider.disabled = false;
                printImageButton.disabled = false;
                openTab('tabImage'); // Switch to the Image tab
                log('Text rendered to image. Go to "Print Image" tab to preview and print.');

            } catch (err) {
                log(`--- TEXT RENDER ERROR ---`);
                log(err.message);
            } finally {
                generateTextButton.disabled = false;
            }
        });

        /**
         * Creates the 'GS v 0' bitmap header as a Uint8Array.
         */
        function createBitmapHeader(sliceHeight) {
            const widthInBytes = PRINTER_WIDTH_PX / 8; // 48 bytes
            return new Uint8Array([
                0x1D, 0x76, 0x30, 0x00, // 'GS v 0' command, mode 0
                widthInBytes, 0,         // Width: 48 bytes
                sliceHeight, 0           // Height: 1-8 dots
            ]);
        }

        /**
         * REFACTORED: Main print logic, now reusable.
         * @param {Image} imageToPrint The Image object to print.
         * @param {number} contrastThreshold The B&W threshold.
         * @param {boolean} [skipFeed=false] Whether to skip feeding lines at the end.
         */
        async function printImage(imageToPrint, contrastThreshold, skipFeed = false) {
            if (!writer) throw new Error("Printer is not connected.");
            if (!imageToPrint) throw new Error("No image provided to print.");

            // 1. Create an off-screen canvas to get original pixel data
            const printCanvas = document.createElement('canvas');
            const printCtx = printCanvas.getContext('2d');
            const scaledHeight = Math.floor(imageToPrint.height * (PRINTER_WIDTH_PX / imageToPrint.width));
            printCanvas.width = PRINTER_WIDTH_PX;
            printCanvas.height = scaledHeight;
            printCtx.drawImage(imageToPrint, 0, 0, PRINTER_WIDTH_PX, scaledHeight);

            // 2. Get its pixel data
            const originalImageData = printCtx.getImageData(0, 0, PRINTER_WIDTH_PX, scaledHeight);

            // 3. Pass this data to the printer function
            await printImageDataToPrinter(originalImageData, contrastThreshold, skipFeed);
        }

        /**
         * Main function to convert ImageData to raw printer buffers and send.
         * @param {ImageData} imageData The *original* (color/grayscale) pixel data
         * @param {number} contrastThreshold The threshold used for B&W conversion
         * @param {boolean} [skipFeed=false] Whether to skip feeding lines at the end.
         */
        async function printImageDataToPrinter(imageData, contrastThreshold, skipFeed = false) {
            if (!writer) throw new Error("Printer is not connected.");

            const width = imageData.width, height = imageData.height;

            function isPixelBlackForPrinter(x, y) {
                const i = (y * width + x) * 4;
                const r = imageData.data[i], g = imageData.data[i + 1], b = imageData.data[i + 2];
                const average = (0.2126 * r + 0.7152 * g + 0.0722 * b);
                return (average < contrastThreshold);
            }

            log('Sending INIT command...');
            await writer.write(INIT);
            log('Starting image data stream...');
            const sliceWidthInBytes = PRINTER_WIDTH_PX / 8;

            for (let y_slice = 0; y_slice < height; y_slice += SLICE_HEIGHT_PX) {
                const actualSliceHeight = Math.min(SLICE_HEIGHT_PX, height - y_slice);
                const header = createBitmapHeader(actualSliceHeight);
                await writer.write(header);

                const sliceData = new Uint8Array(sliceWidthInBytes * actualSliceHeight);
                let sliceBufferIndex = 0;

                for (let y = 0; y < actualSliceHeight; y++) {
                    const currentY = y_slice + y;
                    for (let x_byte = 0; x_byte < sliceWidthInBytes; x_byte++) {
                        let horizontalByte = 0;
                        for (let bit = 0; bit < 8; bit++) {
                            const currentX = (x_byte * 8) + bit;
                            if (isPixelBlackForPrinter(currentX, currentY)) {
                                horizontalByte |= (1 << (7 - bit));
                            }
                        }
                        sliceData[sliceBufferIndex++] = horizontalByte;
                    }
                }
                await writer.write(sliceData);
            }
            log('Image data stream finished.');

            // --- MODIFIED: Only feed paper if skipFeed is false ---
            if (!skipFeed) {
                log('Sending feed commands...');
                await writer.write(FEED_ONE_LINE);
                await writer.write(FEED_ONE_LINE);
                await writer.write(FEED_ONE_LINE);
            } else {
                log('Skipping feed commands for this print.');
            }
        }

        // --- NEW: Last.fm Polling Logic ---

        startPollingButton.addEventListener('click', () => {
            const apiKey = lastFmApiKey.value;
            const username = lastFmUsername.value;

            if (!apiKey || !username) {
                log('Please enter both Last.fm API Key and Username.');
                return;
            }
            if (pollingInterval) clearInterval(pollingInterval); // Clear any old one

            log('Starting Last.fm polling...');
            lastFmStatus.textContent = 'Polling...';
            startPollingButton.disabled = true;
            stopPollingButton.disabled = false;
            lastPrintedTrack = ""; // Reset to print first song

            fetchLastFm(); // Call immediately
            pollingInterval = setInterval(fetchLastFm, 30000); // Poll every 30 seconds
        });

        stopPollingButton.addEventListener('click', () => {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
                log('Stopped Last.fm polling.');
                lastFmStatus.textContent = 'Polling stopped.';
                startPollingButton.disabled = false;
                stopPollingButton.disabled = true;
            }
        });

        async function fetchLastFm() {
            const apiKey = lastFmApiKey.value;
            const username = lastFmUsername.value;
            if (!apiKey || !username || !writer) {
                log('Last.fm poller stopped: Missing details or printer disconnected.');
                stopPollingButton.click(); // Stop polling
                return;
            }

            const url = `https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${username}&api_key=${apiKey}&format=json&limit=1`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Last.fm API error: ${response.statusText}`);

                const data = await response.json();

                if (data.error) throw new Error(`Last.fm API error: ${data.message}`);

                const track = data.recenttracks?.track?.[0];
                if (!track) {
                    lastFmStatus.textContent = 'No recent tracks found.';
                    return;
                }

                // Check if the track is currently playing
                if (track["@attr"]?.nowplaying === "true") {

                    // --- MODIFIED: Add timestamp ---
                    const now = new Date();
                    const hours = now.getHours().toString().padStart(2, '0');
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    const timestamp = `${hours}:${minutes}`;

                    const trackName = `${timestamp} ${track.artist["#text"]} - ${track.name}`;
                    // --- End Modification ---

                    lastFmStatus.textContent = `Now Playing: ${trackName}`;

                    // Check if it's a *new* song (timestamp will make it unique)
                    if (trackName !== lastPrintedTrack) {
                        log(`--- NEW SONG DETECTED ---`);
                        log(`Song: ${trackName}`);
                        lastPrintedTrack = trackName;

                        log('Generating image for Last.fm track...');
                        // Use default contrast of 128 for automatic printing
                        const textImage = await generateImageFromText(trackName);

                        log('Sending Last.fm track to printer (no feed)...');
                        // --- MODIFIED: Pass true for skipFeed ---
                        await printImage(textImage, 128, true);
                        log('--- Last.fm Print Finished ---');
                    }
                } else {
                    // Not playing anything right now
                    lastFmStatus.textContent = `Last Played: ${track.artist["#text"]} - ${track.name}`;
                }

            } catch (err) {
                log(`--- LAST.FM ERROR ---`);
                log(err.message);
                lastFmStatus.textContent = `Error: ${err.message}`;
                stopPollingButton.click(); // Stop on error
            }
        }

    </script>
</body>

</html>